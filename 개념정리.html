<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- 
-//W3C//DTD XHTML 1.0 Transitional//EN은 XHTML 1.0 Transitional 버전을 의미합니다. 
이는 XHTML(Extensible Hypertext Markup Language)이라는 XML 기반의 HTML 버전으로, 
웹 브라우저에게 이 문서가 XHTML 1.0 Transitional 규격을 따르는 것임을 알려줍니다.

"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"는 
DTD(Document Type Definition) 파일의 경로를 지정하는 것으로, 
XHTML 1.0 Transitional 버전의 DTD 파일을 참조합니다. 
DTD 파일은 해당 HTML 버전의 문서 구조와 요소들의 정의를 포함하고 있습니다.

이 선언문은 웹 브라우저가 문서를 올바르게 해석하고 렌더링하는 데 도움을 주는 역할을 합니다. 
또한 웹 표준을 준수하는 것으로서, 웹 브라우저의 호환성과 웹 개발의 통일성을 유지하는 데 도움을 줍니다. -->


<!-- overloading vs overriding -->
<!-- 오버로딩 : 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 말한다.
오버라이딩 : 상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것을 말한다. -->


<!-- @RequestMappin -->
<!-- 어노테이션 기반의 컨트롤러를 지원하는 핸들러 매핑과 어댑터
-> 자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 
기능을 수행하도록 하는 기술이다. -
프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
-> 핸들러 매핑 / 핸들러 어댑터를 통래 실제 핸들러가 호출 -->
<!-- RequestMapping의 인터페이스
RequestMappingHandlerMapping: RequestMapping의 핸들러 매핑
-> HandlerMapping: 특정 Controller를 찾을 수 있어야 함
RequestMappingHandlerAdapter: RequestMapping의 핸들러 어댑터
-> HandlerAdapter: Handler Mapping을 통해 찾은 Handler를 실행 할 수 있음
-->
<!-- 동작방식 -->
<!-- HTTP Request를 통해 요청
핸들러 매핑 탐색: HandlerMapping을 순회하며 해당하는 RequestMappingHandlerMapping 반환
핸들러 어댑터 조회: HandlerAdapter.supports()를 순서대로 호출하며 처리할 수 있는 핸들러 어댑터를 탐색
핸들러 어댑터 실행: RequestMappingHandleAdapter로 실제 핸들러 호출
뷰 리졸버 실행: 논리주소를 싱제 물리 주소로 반환
view: 뷰 랜더링
-->
<!-- 논리주소와 물리주소
-> 논리 주소는 CPU와 실행중인 프로그램 입장에서 바라본 주소로 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소를 의미
-> 물리 주소는 메모리 입장에서 바라본 주소, 말 그대로 정보가 실제로 저장된 하드웨어상의 주소를 의미
-->
<!-- 뷰 랜더링 (뷰 리졸루션)
컨트롤러에서는 , 직접적으로 브라우저에 랜더링하는 HTML을 생성해내는 메소드가 없음
대신 랜더링을 위한 데이터를 모델에 담아 뷰에 전달하는 역할을 함. 뷰의 논리적 이름만 전달.
ViewResolver는 뷰의 이름과 Locale을 넘겨받고 View를 리턴해줌
View는 모델을 전달받은 후 서블릿 요청과 응답 객체를 받아 결과를 랜더링 해줌
-->

<!-- XXS (Cross Site Scripting) 공격 -->
<!-- 게시판이나 웹 메일 등에 자바 스크립트와 같은 스크립트 코드를 삽입 해
개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격.
크게 Reflected XSS 와 Stored XSS 그리고 DOM Based XSS 세가지로 분류 할 수 있다.
-->
<!-- Reflected XSS 
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 URL을 사용자에게 노출 시킨다.
사용자가 해당 URL을 클릭할 경우, 취약한 웹 사이트의 서버에 스크립트가 포함 된 URL을 통해
Request를 전송하고 , 웹서버에서는 해당 스크립트를 포함한 Response를 전송하게 된다.
-->
<!-- Stored XSS
게시판에 스크립트를 삽입하는 공격 방식
공격자는 게시판에 스크립트를 삽입한 후 공격 대상자가 해당 게시글을 클릭하도록 유도한다.
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 게시글을 웹 사이트에 업로드한다.
게시글의 URL을 사용자에게 노출하고 사용자가 게시글을 확인함으로써
URl에 대한 요청을 서버에 전송하게 된다.
웹 서버에서 스크립트를 포함한 Response를 전송하며 공격이 수행된다.
-->

<!-- dextupload -->
<!-- 윈도우 서버는 리눅스 서버의 아파치와 다르게 파일을 업로드 하기위해서 업로드 컴포넌트가 필요합니다.  --> 
<!-- 업로드 컴포넌트 --> 
<!-- 웹 환경에서 브라우저를 ㅌㅇ해 웹서버로 파일을 전송할 수 있도록 해주는 것
실행 환경에 따라 클라이언트 제품과 서버 제품으로 구분됩니다. -->
<!--  DEXTUpload 란? --> 
<!-- 웹브라우저로부터 웹 서버의 파일업로드 기능을 지원하는 HTTP프로토콜 기반의 
    서버측 컴포넌트컴포넌트(Component)로 윈도우 플랫폼에서 IIS로 호스팅되는 
    모든 웹사이트에서 사용할 수 있습니다.
-->

<!-- AOP (Aspect Oriented Programming) 관점 지향 프로그래밍 -->
<!-- 관점지향: 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고
    그 관점을 기준으로 각각 모듈화 하는 것 -->
<!-- 모듈화: 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것 -->
<!-- AOP에서 각 관점을 기준으로 로직을 모듈화 한다는 것은 
코드들을 부분적으로 나누어서 모듈화 하겠다는 의미이다.
이때 소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들을
흩어진 관심사(Crosscutting Concerns)라 부른다. 
이 흩어진 관심사를 Aspect로 모듈화 하고 핵심적인 비즈니스 로직에서 분리하여
재사용 하겠다는 것이 AOP의 취지이다.-->
<!-- AOP의 주요 개념
-> Aspect: 흩어진 관심사를 모듈화 한것. 주로 부가기능을 모듈화함.
-> Target: Aspect를 적용하는 곳 (Class, Method ...)
-> Advice: 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
-> JointPoint: Advice가 적용 될 위치, 끼어 들 수 있는 지점.
매서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 다양한 시점에 적용 가능
-> PointCut: JointPoint의 상세한 스펙을 정의한 것. 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있다.
-->
<!-- 스프링 AOP 특징 -->
<!-- 프록시 패턴 기반의 AOP구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서다. 
스프링 빈에만 AOP가 적용 가능하다.
모든 AOP기능을 제공하는 것이 아닌 스프링 IOC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 지원하는 것이 목정
(중복 코드 , 프록시 클래스 작성의 번거로우ㅜㅁ, 객체들 간 관계 복잡도 증가)-->

<!-- dispatcher-servlet -->
<!-- JAVA Servlet은 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 서블릿이라 불린다. 
자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
즉, 서블릿은 클라이언트 요청을 처리하고, 그 결과를 반환하는 웹 프로그래밍 기술이다.
-->
<!-- 디스패처 서블릿(Dispatcher Servlet) -->
<!-- 디스패처 서블릿 또한 서블릿의 일종으로 가장 먼저 요청을 받고 적절하게 처리해줄 컨트롤러를 찾아서
정해주는 역할을 한다. 
디스패처 서블릿은 HttpServlet을 상속한다.
스프링 MVC의 중앙 서블릿이며 어플리케이션으로 오는 모든 요청을 핸들링하고 공동작업을 처리해준다.
실제 작업(비즈니스 로직, 예외처리 등)은 위임 컴포넌트를 통해 수행된다.
디스패처 서블릿을 프론트 컨트롤러 라고도 부른다.
프론트 컨트롤러는 서블릿 컨테이너 맨 앞에서 모든 요청을 받아 처리해주는 컨트롤러를 의미한다.
서블릿이기 때문에 정적 자원과 동적 자원을 따로 처리 할 수 있다.
디스패처 서블릿에서 요청을 처리할 컨트롤러를 먼저 찾고, 
컨트롤러가 없을땐 2차로 설정된 정적 자원을 탐색한다.
이를 통해 효율적인 리소스 관리가 가능해진다.
-->
<!-- 디스패처 서블릿 설정 방법 -->
<!-- 자바나 web.xml을 통해 등록 및 초기화 되어야 사용 가능하다.
톰캣 등 서블릿 컨테이너를 통해 디스패처 서블릿의 생명주기를 관리하는 것이 일반적이다. 
-->
<!-- 구조 -->
<!-- Sevlet Container
서블릿은 스스로 동작하지 않는다. 보통 서블릿을 관리할 서블릿 컨테이너(톰캣 등)를 사용한다.
서블릿 컨테이너는 싱글톤인 서블릿 객체의 생명주기를 관리한다.
또한 웹서버와 소켓으로 통신하며, 클라이언트의 요청을 받고 응답을 보내준다.
멀티 쓰레드 처리도 지원한다. -->
<!-- WebApplicationContext
디스패쳐 서블릿은 Servlet WebApplication을 생성하고 보통 Root WebApplicationContext를 생성한다. 
서블릿 WebApplicationContext안에는 ServletContext와 연관된 Servlet링크들이 있다.
Controller , ViewResolver, HandlerMapping 등이 이 안에 있다.
RequestContextUtils의 정적 메소드들을 사용해 어플리케이션이 WebApplication을 조회할 수 있다.
Root WebApplicationContex 가 있는 경우 infra bean이 이 안에 들어간다.
Repository, Service 빈 등이 인프라 빈이다.
WebApplicationContext 설정은 java나 web.xml을 통해 할 수 있다.
-->
<!-- 스페셜 빈 (Special Bean) -->
<!-- 디스패처 서블릿은 요청을 처리하기 위해 위임 컴포넌트에 실제 작업을 맡긴다. 
이런 위임 컴포넌트를 스페셜 빈(Special Bean)이라고도 부른다.
스페셜 빈은 프레임워크 계약을 구현하는 스프링 관리 객체 인스턴스를 의미한다.
쉽게 말하면 스프링에서 제공하는 주요 빈들이다.
스페셜 빈 들마다 제공되는 일반적인 설정들이 있지만 사용자가 임의로 재정의하거나 교체가 가능하다.
-->
<!-- 스페셜 빈 종류
handlerMapping: 요청을 처리할 컨트롤러를 찾는다.
handlerAdapter: 요청을 컨트롤러로 전달한다.
handlerExceptionResolver: 요청에 대한 예외 발생 (핸들러 매핑 도중, 컨트롤러 실행도중)시 처리해 준다.
viewResolver: 리턴값에 대한 뷰 컴포넌트를 반환한다. 
string으로 뷰 이름을 전달받았을 때  이를 modelAndView등의 객체로 반환한다.
LocaleResolver: Locle을 결정한다.
-> Locale: 유저의 언어, 지역, 출력형식 등을 정의하는 문자열
MultipartResolver: 멀티파트 파일 업로드를 처리해준다.
-> Multipart: HTTP응답의 바디를 여러 파트로 나눠서 보내줄 때의 파일 형식을 의미한다.
-->
<!-- 작동방식 -->
<!-- 클라이언트 요청을 디스패처 서블릿이 받는다. 이때 filter를 경유할 수 있다.
요청 정보를 보고 Servlet WebApplicationContext안에서 HandlerMapping을 통해 요청을 위임할 컨트롤러를 검색해 찾는다.
찾은 컨트롤러로 요청을 위임할 HandlerAdapter를 찾는다. 이때 Interceptor preHandle이 실행된다.
HandlerAdapter가 컨트롤러로 요청(HttpRequest)을 위임한다.
Argument Resolver가 파라미터를 처리해 컨트롤러로 보낸다.
컨트롤러는 Root WebApplicationContext 속 Service, Repository 등을 호출해가며 비즈니스 로직을 처리한다.
컨트롤러 매소드에서 최종적인 반환값(Response Entity)이 리턴된다.
리턴값에 대해 Interceptor postHandle이 실행된다.
핸들러 어댑터 리턴값을 viewResolver에 전달한다.
viewResolver가 View를 검색하고 찾은 View에 응답을 전달한다.
이후 Interceptor afterCompletion이 실행된다.
디스패처 서블릿에서 View로부터 받은 응답을 클라이언트로 반환해준다. -->

<!-- html 4 / html 5 -->
<!-- html 5로 넘어오면서 문법이 명확하고 간략해 졌다.
멀티미디어 요소 video 및에 audio 추가. html 4 까지 Sliverlight, flash등의 지원이 필요했었다.
사용자 위치 식별 액세스 추가. GeoLocation을 이용하여 보다 간단하게 사용자 위치 액세스 가능
Client 측면의 저장소(WebStorage) html4에서는 browser cache를 이용하여 데이터를 저장했다.
html 5에서는 javascript 인터페이스를 통해 web sql 데이터베이스 응용프로그램 사용이 가능하다.
Client, Server에 WebSocket 통신 추가. html4에서 웹 소켓이 없어, streaming, polling을 통해 데이터 교환을 했다.
html4, javascript가 동일한 thread에서 실행되던 것을 html 5 부터 브라우저 인터페이스를 별도로 실행시킬 수 있다. -->

<!-- smart editor 2. last -->
<!-- 네이버에서 제공하는 웹상 게시판 글 편집기 -->

<!-- dscms / cms -->