<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- 
-//W3C//DTD XHTML 1.0 Transitional//EN은 XHTML 1.0 Transitional 버전을 의미합니다. 
이는 XHTML(Extensible Hypertext Markup Language)이라는 XML 기반의 HTML 버전으로, 
웹 브라우저에게 이 문서가 XHTML 1.0 Transitional 규격을 따르는 것임을 알려줍니다.

"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"는 
DTD(Document Type Definition) 파일의 경로를 지정하는 것으로, 
XHTML 1.0 Transitional 버전의 DTD 파일을 참조합니다. 
DTD 파일은 해당 HTML 버전의 문서 구조와 요소들의 정의를 포함하고 있습니다.

이 선언문은 웹 브라우저가 문서를 올바르게 해석하고 렌더링하는 데 도움을 주는 역할을 합니다. 
또한 웹 표준을 준수하는 것으로서, 웹 브라우저의 호환성과 웹 개발의 통일성을 유지하는 데 도움을 줍니다. -->


<!-- overloading vs overriding -->
<!-- 오버로딩 : 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 말한다.
오버라이딩 : 상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것을 말한다. -->


<!-- @RequestMappin -->
<!-- 어노테이션 기반의 컨트롤러를 지원하는 핸들러 매핑과 어댑터
-> 자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 
기능을 수행하도록 하는 기술이다. -
프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
-> 핸들러 매핑 / 핸들러 어댑터를 통래 실제 핸들러가 호출 -->
<!-- RequestMapping의 인터페이스
RequestMappingHandlerMapping: RequestMapping의 핸들러 매핑
-> HandlerMapping: 특정 Controller를 찾을 수 있어야 함
RequestMappingHandlerAdapter: RequestMapping의 핸들러 어댑터
-> HandlerAdapter: Handler Mapping을 통해 찾은 Handler를 실행 할 수 있음
-->
<!-- 동작방식 -->
<!-- HTTP Request를 통해 요청
핸들러 매핑 탐색: HandlerMapping을 순회하며 해당하는 RequestMappingHandlerMapping 반환
핸들러 어댑터 조회: HandlerAdapter.supports()를 순서대로 호출하며 처리할 수 있는 핸들러 어댑터를 탐색
핸들러 어댑터 실행: RequestMappingHandleAdapter로 실제 핸들러 호출
뷰 리졸버 실행: 논리주소를 싱제 물리 주소로 반환
view: 뷰 랜더링
-->
<!-- 논리주소와 물리주소
-> 논리 주소는 CPU와 실행중인 프로그램 입장에서 바라본 주소로 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소를 의미
-> 물리 주소는 메모리 입장에서 바라본 주소, 말 그대로 정보가 실제로 저장된 하드웨어상의 주소를 의미
-->
<!-- 뷰 랜더링 (뷰 리졸루션)
컨트롤러에서는 , 직접적으로 브라우저에 랜더링하는 HTML을 생성해내는 메소드가 없음
대신 랜더링을 위한 데이터를 모델에 담아 뷰에 전달하는 역할을 함. 뷰의 논리적 이름만 전달.
ViewResolver는 뷰의 이름과 Locale을 넘겨받고 View를 리턴해줌
View는 모델을 전달받은 후 서블릿 요청과 응답 객체를 받아 결과를 랜더링 해줌
-->

<!-- XXS (Cross Site Scripting) 공격 -->
<!-- 게시판이나 웹 메일 등에 자바 스크립트와 같은 스크립트 코드를 삽입 해
개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격.
크게 Reflected XSS 와 Stored XSS 그리고 DOM Based XSS 세가지로 분류 할 수 있다.
-->
<!-- Reflected XSS 
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 URL을 사용자에게 노출 시킨다.
사용자가 해당 URL을 클릭할 경우, 취약한 웹 사이트의 서버에 스크립트가 포함 된 URL을 통해
Request를 전송하고 , 웹서버에서는 해당 스크립트를 포함한 Response를 전송하게 된다.
-->
<!-- Stored XSS
게시판에 스크립트를 삽입하는 공격 방식
공격자는 게시판에 스크립트를 삽입한 후 공격 대상자가 해당 게시글을 클릭하도록 유도한다.
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 게시글을 웹 사이트에 업로드한다.
게시글의 URL을 사용자에게 노출하고 사용자가 게시글을 확인함으로써
URl에 대한 요청을 서버에 전송하게 된다.
웹 서버에서 스크립트를 포함한 Response를 전송하며 공격이 수행된다.
-->

<!-- dextupload -->
<!-- 윈도우 서버는 리눅스 서버의 아파치와 다르게 파일을 업로드 하기위해서 업로드 컴포넌트가 필요합니다.  --> 
<!-- 업로드 컴포넌트 --> 
<!-- 웹 환경에서 브라우저를 ㅌㅇ해 웹서버로 파일을 전송할 수 있도록 해주는 것
실행 환경에 따라 클라이언트 제품과 서버 제품으로 구분됩니다. -->
<!--  DEXTUpload 란? --> 
<!-- 웹브라우저로부터 웹 서버의 파일업로드 기능을 지원하는 HTTP프로토콜 기반의 
    서버측 컴포넌트컴포넌트(Component)로 윈도우 플랫폼에서 IIS로 호스팅되는 
    모든 웹사이트에서 사용할 수 있습니다.
-->

<!-- AOP (Aspect Oriented Programming) 관점 지향 프로그래밍 -->
<!-- 관점지향: 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고
    그 관점을 기준으로 각각 모듈화 하는 것 -->
<!-- 모듈화: 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것 -->
<!-- AOP에서 각 관점을 기준으로 로직을 모듈화 한다는 것은 
코드들을 부분적으로 나누어서 모듈화 하겠다는 의미이다.
이때 소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들을
흩어진 관심사(Crosscutting Concerns)라 부른다. 
이 흩어진 관심사를 Aspect로 모듈화 하고 핵심적인 비즈니스 로직에서 분리하여
재사용 하겠다는 것이 AOP의 취지이다.-->
<!-- AOP의 주요 개념
-> Aspect: 흩어진 관심사를 모듈화 한것. 주로 부가기능을 모듈화함.
-> Target: Aspect를 적용하는 곳 (Class, Method ...)
-> Advice: 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
-> JointPoint: Advice가 적용 될 위치, 끼어 들 수 있는 지점.
매서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 다양한 시점에 적용 가능
-> PointCut: JointPoint의 상세한 스펙을 정의한 것. 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있다.
-->
<!-- 스프링 AOP 특징 -->
<!-- 프록시 패턴 기반의 AOP구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서다. 
스프링 빈에만 AOP가 적용 가능하다.
모든 AOP기능을 제공하는 것이 아닌 스프링 IOC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 지원하는 것이 목정
(중복 코드 , 프록시 클래스 작성의 번거로우ㅜㅁ, 객체들 간 관계 복잡도 증가)-->
<!-- AOP 용어
-> Target : AOP 적용 대상 biz 로직
-> Advice : AOP 기능 type & 실행 시점
before : biz 실행 전
after : biz 실행 후
after-throwing : biz 예외처리 AOP
after-returning : biz 리턴값 반환 후
-> Join Point : 적용할 위치
pointcut : advice가 적용될 지점
execution() , within() 함수로 지점 호출  -->
<!-- AOP : XML 기반 설정 -->
<!-- 
    <aop:aspectj-autoproxy /> : AOP 사용을 위한 필수 설정
    biz와 common을 bean binding (필수)
    <aop:config></aop:config> : AOP 설정 구간
    <aop:aspect ref="common"></aop:aspect> : Advice 작성구간
    ref : AOP bean 호출
    <aop:ponitcut id="bizLogig" expression="..."/> : pointcut의 expression, 즉 advice가 적용될 지점을 id로 참조할 수 있게 생성
    -> expression 작성방법
    -- excution() : "execution(* step02.aop.biz.Car.buy*(..))"
    Car.java에서 buy~() 라는 이름을 가짐 함수 모두에 적용
    (..) : 모든 종류의 parameter일 때 사용되는 표현 (int)로 작성시 int 데이터타입의 parameter를 1개 받는 함수에만 적용
    -- within() : "within(step02.aop.biz.Car)"
    선택된 biz 객체에 대해 모두 적용
    "within(step02.aop.biz.*)" 과 같은 방식으로 1개 이상에 bean 객체 선택 가능
    -- execution() & within() 차이점 :
    within() 의 최대 조회 깊이는 .java , biz 클래스 내부 메소드에 따라 구분이 불가능 함으로
    구체적인 구분이 필요하다면 execution() 사용
-->
<!-- XML : before & after -->
<!-- 
    <aop:before method="beforeNotice" pointcut-ref="bizLogic"/> :
    bizLogic pointcut 기준에 맞는 함수 실행 전에 beforeNotice() 함수호출
    <aop:after method="afterNotice" pointcut-ref="bizLogic"/> :
    bizLogic pointcut 기준에 맞는 함수 실행 전에 afterNotice() 함수호출
-->
<!-- XML : after-throwing -->
<!-- 
    biz 로직이 실행될 때 try / catch 문에서 던지는 Exception을 AOP 로직이 받는다.
    AOP 로직에서 받는 Exception 변수명과 동일하게 작성
    -> pointcut : 개별로 지정하고 싶을 때 바로 tag 안에 작성
    -> pointcut-ref : 기존 <aop:pointcut/>을 참조하고 싶을 때 id 기준으로 binding
-->
<!-- XML : after-returning -->
<!-- 
    biz 로직이 return 하는 값을 AOP 로직이 parameter로 받음
    AOP 로직에서 받는 parameter 변수명과 동일하게 작성
    -> parameter의 Data-type은 Object로, 유동적인 반환을 가능하게 설계 권장
-->
<!-- XML : Around -->
<!-- 
    before, after, throwing, returning을 하나의 tag로 처리 가능
    -> ProceedJoinPoint : Around Adivce에서 사용할 공통기능
    메서드는 파라미터로 전달받은 ProceedingJointPoint의 proceed() 메소드로 실행
 -->

<!-- dispatcher-servlet -->
<!-- JAVA Servlet은 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 서블릿이라 불린다. 
자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
즉, 서블릿은 클라이언트 요청을 처리하고, 그 결과를 반환하는 웹 프로그래밍 기술이다.
-->
<!-- 디스패처 서블릿(Dispatcher Servlet) -->
<!-- 디스패처 서블릿 또한 서블릿의 일종으로 가장 먼저 요청을 받고 적절하게 처리해줄 컨트롤러를 찾아서
정해주는 역할을 한다. 
디스패처 서블릿은 HttpServlet을 상속한다.
스프링 MVC의 중앙 서블릿이며 어플리케이션으로 오는 모든 요청을 핸들링하고 공동작업을 처리해준다.
실제 작업(비즈니스 로직, 예외처리 등)은 위임 컴포넌트를 통해 수행된다.
디스패처 서블릿을 프론트 컨트롤러 라고도 부른다.
프론트 컨트롤러는 서블릿 컨테이너 맨 앞에서 모든 요청을 받아 처리해주는 컨트롤러를 의미한다.
서블릿이기 때문에 정적 자원과 동적 자원을 따로 처리 할 수 있다.
디스패처 서블릿에서 요청을 처리할 컨트롤러를 먼저 찾고, 
컨트롤러가 없을땐 2차로 설정된 정적 자원을 탐색한다.
이를 통해 효율적인 리소스 관리가 가능해진다.
-->
<!-- 디스패처 서블릿 설정 방법 -->
<!-- 자바나 web.xml을 통해 등록 및 초기화 되어야 사용 가능하다.
톰캣 등 서블릿 컨테이너를 통해 디스패처 서블릿의 생명주기를 관리하는 것이 일반적이다. 
-->
<!-- 구조 -->
<!-- Sevlet Container
서블릿은 스스로 동작하지 않는다. 보통 서블릿을 관리할 서블릿 컨테이너(톰캣 등)를 사용한다.
서블릿 컨테이너는 싱글톤인 서블릿 객체의 생명주기를 관리한다.
또한 웹서버와 소켓으로 통신하며, 클라이언트의 요청을 받고 응답을 보내준다.
멀티 쓰레드 처리도 지원한다. -->
<!-- WebApplicationContext
디스패쳐 서블릿은 Servlet WebApplication을 생성하고 보통 Root WebApplicationContext를 생성한다. 
서블릿 WebApplicationContext안에는 ServletContext와 연관된 Servlet링크들이 있다.
Controller , ViewResolver, HandlerMapping 등이 이 안에 있다.
RequestContextUtils의 정적 메소드들을 사용해 어플리케이션이 WebApplication을 조회할 수 있다.
Root WebApplicationContex 가 있는 경우 infra bean이 이 안에 들어간다.
Repository, Service 빈 등이 인프라 빈이다.
WebApplicationContext 설정은 java나 web.xml을 통해 할 수 있다.
-->
<!-- 스페셜 빈 (Special Bean) -->
<!-- 디스패처 서블릿은 요청을 처리하기 위해 위임 컴포넌트에 실제 작업을 맡긴다. 
이런 위임 컴포넌트를 스페셜 빈(Special Bean)이라고도 부른다.
스페셜 빈은 프레임워크 계약을 구현하는 스프링 관리 객체 인스턴스를 의미한다.
쉽게 말하면 스프링에서 제공하는 주요 빈들이다.
스페셜 빈 들마다 제공되는 일반적인 설정들이 있지만 사용자가 임의로 재정의하거나 교체가 가능하다.
-->
<!-- 스페셜 빈 종류
handlerMapping: 요청을 처리할 컨트롤러를 찾는다.
handlerAdapter: 요청을 컨트롤러로 전달한다.
handlerExceptionResolver: 요청에 대한 예외 발생 (핸들러 매핑 도중, 컨트롤러 실행도중)시 처리해 준다.
viewResolver: 리턴값에 대한 뷰 컴포넌트를 반환한다. 
string으로 뷰 이름을 전달받았을 때  이를 modelAndView등의 객체로 반환한다.
LocaleResolver: Locle을 결정한다.
-> Locale: 유저의 언어, 지역, 출력형식 등을 정의하는 문자열
MultipartResolver: 멀티파트 파일 업로드를 처리해준다.
-> Multipart: HTTP응답의 바디를 여러 파트로 나눠서 보내줄 때의 파일 형식을 의미한다.
-->
<!-- 작동방식 -->
<!-- 클라이언트 요청을 디스패처 서블릿이 받는다. 이때 filter를 경유할 수 있다.
요청 정보를 보고 Servlet WebApplicationContext안에서 HandlerMapping을 통해 요청을 위임할 컨트롤러를 검색해 찾는다.
찾은 컨트롤러로 요청을 위임할 HandlerAdapter를 찾는다. 이때 Interceptor preHandle이 실행된다.
HandlerAdapter가 컨트롤러로 요청(HttpRequest)을 위임한다.
Argument Resolver가 파라미터를 처리해 컨트롤러로 보낸다.
컨트롤러는 Root WebApplicationContext 속 Service, Repository 등을 호출해가며 비즈니스 로직을 처리한다.
컨트롤러 매소드에서 최종적인 반환값(Response Entity)이 리턴된다.
리턴값에 대해 Interceptor postHandle이 실행된다.
핸들러 어댑터 리턴값을 viewResolver에 전달한다.
viewResolver가 View를 검색하고 찾은 View에 응답을 전달한다.
이후 Interceptor afterCompletion이 실행된다.
디스패처 서블릿에서 View로부터 받은 응답을 클라이언트로 반환해준다. -->

<!-- html 4 / html 5 -->
<!-- html 5로 넘어오면서 문법이 명확하고 간략해 졌다.
멀티미디어 요소 video 및에 audio 추가. html 4 까지 Sliverlight, flash등의 지원이 필요했었다.
사용자 위치 식별 액세스 추가. GeoLocation을 이용하여 보다 간단하게 사용자 위치 액세스 가능
Client 측면의 저장소(WebStorage) html4에서는 browser cache를 이용하여 데이터를 저장했다.
html 5에서는 javascript 인터페이스를 통해 web sql 데이터베이스 응용프로그램 사용이 가능하다.
Client, Server에 WebSocket 통신 추가. html4에서 웹 소켓이 없어, streaming, polling을 통해 데이터 교환을 했다.
html4, javascript가 동일한 thread에서 실행되던 것을 html 5 부터 브라우저 인터페이스를 별도로 실행시킬 수 있다. -->

<!-- smart editor 2. last -->
<!-- 네이버에서 제공하는 웹상 게시판 글 편집기 -->

<!-- 상속 -->
<!-- extends -->
<!-- 부모에서 선언 / 정의를 모두 하며 자식은 메소드 / 변수를 그대로 사용할 수 있다.
일반 클래스의 상속과 abstract 클래스 상속에 사용된다.
클래스 한개만 상속 받을 수 있다.
-->
<!-- implements (인터페이스) -->
<!-- 부모 객체는 선언만 하며 정의는 자식에서 오버라이딩 해서 사용해야함 
자바는 다중 상속을 지원하지 않기 때문에 나온 것 = 여러개 사용이 가능하다.
설계 목적으로 사용 가능하다.
inerface 상속에 사용된다.
class가 interface를 사용할때 써야하지만 interface가 class를 사용할 땐 쓸 수 없다.
implemens한 클래스는 implements의 내용을 다 사용해야 한다.
-->
<!-- abstract
extends와 interface 혼합, extends 하되 몇개는 추상 메소드로 구현되어 있음
-->

<!-- 스프링 인터셉터 -->
<!-- 스프링 MVC 프레임워크에서 HTTP 요청을 가로채어 처리하는 컴포넌트
클라이언트의 요청이 컨트롤러로 전달되기 전에 사전 작업을 수행하거나
컨트롤러 실행 이후에 사후 작업을 수행할 수 있습니다.
즉, 서버에 들어온 Request객체를 컨트롤러 핸들러(url에 매핑되어있는 매서드)로 도달하기 전에 낚아채서
개발자가 원하는 추가적인 작업을 한 후 핸들러로 보낼 수 있도록 해주는 것이 인터셉터입니다. -->
<!-- 전역적인 작업처리
스프링 인터셉터는 여러 컨트롤러에서 공통으로 처리해야 하는 작업을 중앙에서 관리할 수 있습니다.
예를들어 인증이나 권한검사, 로깅 등과 같은 전역적인 작업을 인터셉터에서 처리할 수 있습니다.
이는 코드의 중복을 줄이고 유지보수성을 향상시키는데 도움을 줍니다. -->
<!-- 요청 처리 제어
인터셉터는 HTTP 요청 전후의 흐름을 제어할 수 있습니다.
클라이언트의 요청이 컨트롤러에 도달하기 전에 사전 작업을 수행하거나,
컨트롤러의 실행 이후에 사후 작업을 수행하는 등의 제어가 가능합니다.
이를 통해 요청의 전처리나 후처리를 담당할 수 있습니다. -->
<!-- 유연한 설정
스프링 인터셉터는 다양한 방식으로 설정할 수 있습니다.
XML, 애노테이션, JavaConfig 등의 설정 방법을 사용하여 인터셉터를 관리할 수 있습니다. -->
<!-- 다양한 용도에 활용 가능
스프링 인터셉터는 다양한 용도로 활용할 수 있습니다.
주로 인증과 권한 검사, 로깅, 트랜잭션 관리 등의 전역적인 작업을 처리하는데 사용되지만,
요청처리의 어떤 단계에서든 원하는 작업을 수행할 수 있습니다. -->
<!-- 다중 인터셉터 지원 -->
<!-- 개발자가 특정 Controller의 핸들러가 실행되기 전이나 후에 추가적인 작업을 원할때 사용합니다.
스프링 인터셉터를 사용함으로써 코드의 중복을 줄이고 관심사를 분리하여 개발자는 핵심 비즈니스 로직에 집중할 수 있습니다.
또한 유연한 설정 방식과 다중 인터셉터 지원으로 인해 개발자는 프로젝트의 요구에 맞게 인터셉터를 활용할 수 있습니다. -->
<!-- Spring Interceptor의 작동원리
-> HandlerMapping 검색 : 클라이언트의 요청이 들어오면 먼저 HandlerMapping이라는 Spring 컴포넌트가
요청과 관련된 적절한 컨트롤러를 찾는다. 
HandlerMapping은 요청 URL을 기반으로 컨트롤러를 선택하는 역할을 한다.
-> Intercepter 체인 생성 : HandlerMapping은 해당 컨트롤러와 연결된 Interceptor 체인을 생성한다.
Interceptor 체인은 여러개의 Interceptor 객체로 구성 될 수 있으며, 각각의 Interceptor는 요청을 가로 채고 처리하는 역할을 수행한다.
-> PreHandle 매서드 호출 : PreHandle 매서드 실행 후, HandlerMapping은 적절한 컨트롤러를 호출합니다.
컨트롤러는 클라이언트 요청을 처리하고 결과를 반환합니다.
-> PostHandle 매서드 호출 : 컨트롤러가 실행된 후에는 Interceptor 체인의 각 Interceptor의 PostHandle 매서드가 호출됩니다.
PostHandle 매서드는 컨트롤러의 실행 결과를 가로채고, 후속 작업을 수행할 수 있습니다.
-> View 랜더링 및 응답 : PostHandle 매서드 실행 후, HandlerMapping은 적절한 View를 랜더링하여 클라이언트에게 응답을 보냅니다.
-> AfterCompletion 메서드 호출 : 응답이 완료되면 Interceptor 체인의 각 Interceptor의 AfterCompletion 매서드가 호출됩니다.
AfterCompletion 매서드는 요청 처리가 완료된 후에 실행되며, 리소스 정리나 로깅 등의 작업을 수행할 수 있습니다.
-->
<!-- HandlerInterceptor 인터페이스 -->
<!-- 스프링 인터셉터는 HandlerInterceptor 인터페이스를 구현하여 작성됩니다.
-> preHandle(): 컨트롤러 실행 전에 호출되는 매서드입니다.
요청을 가로채고 사전 작업을 수행할 수 있습니다.
이 메서드가 true를 반환하면 요청은 계속 진행되고 false를 반환하면 요청 처리가 중단됩니다.
-> postHandle(): 컨트롤러 실행 이후에 호출되는 매서드입니다. 컨트롤러의 실행 결과에 대한 후처리 작업을 수행할 수 있습니다.
-> afterCompletion(): 뷰 랜더링까지 안료된 후에 호출되는 매서드입니다. 최종적인 작업 처리를 수행할 수 있습니다.
-->
<!-- 장점 
-> 중앙 집중적인 공통 기능 관리
Interceptor를 사용하면 로그인 체크, 권한 검사, 로깅, 예외 처리 등과 같은 공통적인 기능을 중앙에서 관리할 수 있습니다. 
중복 코드를 제거하고 유지보수성을 향상시킬 수 있습니다.
-> 재사용성과 확장성
Interceptor는 여러 컨트롤러에 적용될 수 있으며, 
Interceptor 체인을 구성하여 여러 개의 Interceptor를 조합할 수 있습니다. 이로 인해 공통 기능을 간편하게 재사용하고, 
필요에 따라 확장할 수 있습니다.
-> 요청 처리 과정 제어
Interceptor는 요청 전(preHandle)과 후(postHandle)에 실행되는 메서드를 제공하여 
요청 처리 과정을 세밀하게 제어할 수 있습니다. 예를 들어, 요청 전에 인증 체크를 수행하거나, 
요청 후에 로깅 작업을 수행할 수 있습니다.
-> 전역 예외 처리
Interceptor를 사용하면 예외 처리를 중앙에서 처리할 수 있습니다. 
예외가 발생하면 Interceptor의 예외 처리 메서드를 활용하여 일관된 방식으로 예외를 처리하고 
사용자에게 적절한 응답을 보낼 수 있습니다. -->
<!-- 단점
-> 성능 영향
Interceptor는 요청과 응답 사이에 위치하므로, 매 요청마다 Interceptor 체인이 실행되어야 합니다. 
Interceptor가 많거나 복잡한 작업을 수행하는 경우 성능에 영향을 줄 수 있습니다. 따라서 Interceptor의 사용은 신중하게 고려되어야 합니다.
-> 컨트롤러와의 결합도
Interceptor는 컨트롤러와 긴밀하게 결합되어 있습니다.
이는 컨트롤러의 변경에 따라 Interceptor도 변경될 수 있음을 의미합니다. 
따라서 Interceptor의 사용은 컨트롤러와의 강한 결합도를 가질 수 있으므로 유지보수에 주의가 필요합니다.
-> 작업의 순서와 조건 제어
Interceptor 체인에서 Interceptor의 실행 순서와 조건 제어를 올바르게 설정해야 합니다. 
잘못된 순서나 조건 설정은 의도하지 않은 동작을 유발할 수 있으므로 주의가 필요합니다.
-> 제한된 범위
Interceptor는 주로 웹 요청을 처리하는 데 사용됩니다. 
따라서 웹 애플리케이션에만 적용 가능하며, 다른 종류의 요청이나 서비스에는 사용할 수 없습니다. -->
<!-- filter, aop와의 비교 -->
<!-- Spring Interceptor
Spring MVC 컴포넌트에 종속적으로 동작합니다. 주로 웹 애플리케이션의 요청과 응답 사이에 위치하여 작업을 수행합니다.
컨트롤러(Controller)에 집중된 기능을 처리하고, 공통 기능을 중앙에서 관리하고 재사용할 수 있습니다.
PreHandle, PostHandle, AfterCompletion 등의 메서드를 제공하여
요청 처리의 다양한 단계에서 작업을 수행할 수 있습니다.
컨트롤러와의 강한 결합도를 가질 수 있으며, 주로 웹 애플리케이션에 사용됩니다. -->
<!-- Filter
Java Servlet 스펙에 정의된 필터(Filter) 인터페이스를 구현하여 동작합니다. 
서블릿 컨테이너에서 동작하는 웹 애플리케이션 전체에 영향을 미칩니다.
웹 애플리케이션의 요청과 응답을 처리하는데 사용됩니다. 
주로 요청과 응답의 헤더 수정, 인코딩 변환, 보안 처리 등을 수행합니다.
DispatcherServlet 이전에 동작하므로 Spring MVC와 독립적으로 동작하며, 여러 개의 서블릿에 적용할 수 있습니다.
Spring Interceptor와 달리 컨트롤러와의 결합도가 낮아서 다양한 웹 애플리케이션에 사용될 수 있습니다. -->
<!-- AOP(Aspect-Oriented Programming)
관점 지향 프로그래밍(Aspect-Oriented Programming)의 개념을 기반으로 동작합니다. 
애플리케이션 전체의 핵심 비즈니스 로직에 공통 기능을 적용하는 데 사용됩니다.
주요한 관심사를 횡단(cross-cutting)하는 방식으로 구현하며, 코드의 흩어진 곳에 횡단 관심사를 분리하여 모듈화합니다.
주요한 관심사를 독립적인 모듈로 구현한 어드바이스(Advice)를 정의하고, 
어드바이스를 적용할 타깃(Target) 객체와 결합시켜 동작합니다.
주로 로깅, 트랜잭션 관리, 보안 등과 같은 공통 기능에 사용됩니다. -->

<!-- ERROR CODE 100 ~ 500 -->
<!-- 우리가 주로보는 400, 403, 404, 500 에러에 대하여
HTTP 400 ERROR : 서버가 요청의 구문을 인식하지 못했다는 뜻으호 문법상의 오류가 있다는 뜻
HTTP 403 ERROR : 서버가 요청을 거부하고 있다는 뜻으로 접근이 금지되었다는 뜻
HTTP 404 ERROR : 서버가 요청한 페이지를 찾을 수 없다는 뜻
HTTP 500 ERROR : 서버에 오류가 발생하여 요청읗 수행할 수 없다는 뜻 -->
<!-- 100 ~ 199 -->
<!-- 100번대 코드들은 클라이언트가 다음에 행동할 정보를 안내합니다.
100 (continue) : 클라이언트에서 첨부문서 (attached document)를 보내기 전에 요청을 보낼때
Expect 헤더에 설정해서 보냅니다.
101 (switching protocol) : 서버가 upgrade헤더에 응답할 수 있고,
다른 플토콜로 전환 한다는 것을 나타냅니다. -->
<!-- 200 ~ 299 -->
<!-- 요청 받은 것이 성공적으로 처리되었음릉 나타냅니다.
200 (ok) : 모든 것이 제대로 처리되었다는걸  나타냅니다.
201 (Created) : 클라이언트의 요청에 대해서 서버가 새로운 문서를 생성하였다는 것을 나타냅니다.
202 (Accepted) : 클라이언트의 요청을 받아 들이기만 했을 뿐 아직 완료되지 않은 상태를 나타냅니다.
204 (No Content) : 새로운 문서가 없어서 브라우저에게 이전 문서를 계속 표시하라고 알려주는 것입니다.
205 (Rest Content) : 새로운 문서가 없더라도 브라우저에서 창을 초기화 하고 문서를 새로 표시한다는 것입니다. -->
<!-- 300 ~ 399 -->
<!-- 파일들이 이동되었을때 쓰이며, 이동하는 위치를 나타내는 Location 헤더가 응답에 포함됩니다.
300 (Multiple Choice) : 요청된 문서가 여러 곳에 있을 때 어떤 문서를 원하는지 묻는 것입니다.
301 (Moved Permanently) : 요청된 문서의 위치가 영구적으로 변했음을 나타내는 것입니다.
302 (Found) : 요청된 문서의 위치가 임시적이라는 것을 나타냅니다.
304 (Not Modified) : 브라우저의 캐시에 들어있는 문서가 최신 문서이니 그것을 그대로 사용하라는 것을 나타냅니다.
305 (Use Proxy) : 요청된 문서를 프록시를 통해서 전송받으라는 것을 나타냅니다. -->
<!-- 400 ~ 499 -->
<!-- 클라이언트 때문에 나타난 오류를 의미합니다.
401 (Bad Request) : 클라이언트에서 잘못된 구문으로 요청하였음을 나타냅니다.
402 (Unauthorized) : 클라이언트가 잘못된 인증정보를 Authorization 헤더에 넣었음을 나타냅니다.
403 (Forbidden) : 클라이언트의 인증 정보에 상관없이 페이지에 대한 접근을 거부한다는 것을 나타냅니다.
404 (Not Found) : 클라이언트가 요청한 자원이 서버에 없다는 것을 나타냅니다.
408 (Request Timeout) : 클라이언트의 요청을 기다릴 수 있는 제한시간이 지났다는 것을 나타냅니다.
410 (Conflict) : 요청된 문서가 사라지고, 새로운 주소를 알 수 없다는 것을 나타냅니다.
413 (Request Entity Too Large) : 요청된 문서가 서버가 다룰 수 있는 문서의 크기보다 큼을 나타냅니다.
415 (Unsupported Media Type) : 요청에 첨부된 문서가 서버가 처리할 수 없는 문서임을 나타냅니다. -->
<!-- 500 ~ 599 -->
<!-- 서버에 의한 오류를 나타냅니다
500 (Internal Server Error) : 서버 내부에 문제가 있음을 나타냅니다.
501 (Not Implemented) : 클라이언트의 요청을 처리하는데 필요한 기능을 서버가 지원하지 않음을 나타냅니다.
502 (Bad Gateway) : 서버가 게이트웨이 역할을 할 때 원격서버로부터 잘못된 응답을 받았음을 나타냅니다.
503 (Service Unavailable) : 서버의 사정으로 응답할 수 없음을 나타냅니다. -->

<!-- Annotation -->
<!-- 코드 사이의 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술
실제 데이터가 아닌 데이터를 위한 데이터로 메타 데이터(meta data)로 불린다. -->
<!-- 어노테이션 용도
컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공.
소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보제공
실행시 (런타임) 특정 기능을 실행하도록 정보제공 -->
<!-- 어노테이션 순서
정의 , 클래스에 배치, 코드 실행중 Reflection을 이용하여 추가 정보 획득하여 기능 실행
-> Reflection : JVM에서 실행되는 애플리케이션의 런타임 동작을 검사하거나 수정할 수 있는 기능이 필요한 경우 사용.
쉽게 클래스의 구조를 개발자다 확인할 수 있고, 값을 가져오거나 매서드를 호출하는데 사용됨. -->
<!-- @ComponentScan -->
<!-- @Component, @Servicce, @Repository, @Controller, @Configuration 어노테이션이 붙은 Bean을 찾아서
Context에 Bean을 등록해주는 어노테이션
-> Bean 등록 방법: @어노테이션을 이용한다 , 파일에 직접 등록한다. 
-> 직접 등록: ApplicationContext.xml 파일에 <bean id = "example" class = "example" /> 
스프링 부트에서 기능을 제공해 주기 때문에 직접 사용할 일이 잘 없음-->
<!-- @Component -->
<!-- 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 Annotation -->
<!-- @Controller, @Service, @Repository -->
<!--  @Component 어노테이션의 구체화된 형태.
어노테이션을 세분화 함으로써 가독성 측면에서 해당 각각의 어노테이션을 가진 클래스의 역할을 알 수 있게 됨.
-> @Controller : 클라이언트로부터 전달된 데이터를 가공하기 위한 Controller이다.
@RequestMapping(@GetMapping / @PostMapping)을 통해 경로 설정을 하게 된다.
-> @Service : Repository를 통해 DB에 데이터를 가져온 후 컨트롤러에 전달해주는 클래스.
애플리케이션의 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성을 검증하고, 트랜잭션을 처리한다.
레파지토리를 호출하기 때문에 레파지토리에까지 적용되는 @Transactional 애노테이션을 서비스에서 사용한다.
-> @Repository는 해당 클래스가 DB에 접근하는 클래스임을 명시한다. -->

<!-- 의존 객체 자동 주입 (Automatic Dependency Injection) -->
<!-- 스프링 설정 파일에서 혹은 태그로 의존 객체 대상을 명시하지 않아도
    스프링 컨테이너가 자동적으로 의존 대상 객체를 찾아 해당 객체에 필요한 의존성을 주입하는 것 -->
<!-- @Resource -->
<!-- 자바에서 제공하는 어노테이션. 특정 프레임 워크에 종속적이지 않다.
이름 (name) 속성을 기준으로 먼저 찾고 없으면 타입 없으면 @Qualifier 어노테이션을 찾아
성공하면 찾은 속성에 의존성을 주입한다.
<context:annotation-config/> 구문을 꼭 xml 설정파일에 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드 -->
<!-- @Autowired -->
<!-- 스프링에서 지원하는 어노테이션.
주입하려고 하는 객체의 타입이 일치하는지 찾고 타입이 존재하지 않으면
속성명이 일치하는 bean을 컨테이너에서 찾는다. 이름이 없을경우 @Qualifier 어노테이션을 찾아
성공하면 찾은 속성에 의존성을 주입한다.
<context:annotation-config/> 구문을 꼭 xml 설정파일에 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드, 생성자, 일반 메소드 -->
<!-- @Inject -->
<!-- 자바에서 제공하는 어노테이션. 특정 프레임 워크에 종속적이지 않다.
@Aurowired와 동일하게 작동하지만 찾는 순서가 다르다.
타입, @Qualifier, 이름 순.
사용하기 위해서는 maven이나 gradle에 javax 라이브러리 의존성을 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드, 생성자, 일반 메소드  -->
<!-- @Qulifier-->
<!-- 타입이 동일한 bean객체가 여러개 있으면 주입 대상이 한 개여야 하는데 
실제로는 두개 이상의 빈이 존재해 주입할때 사용할 객체를 선택 할 수 없기 때문에
스프링 컨테이너를 초기화 하는 과정에서 Spring이 Exception을 일으킨다.
단, @Autowired가 적용된 필드나 설정 메서드의 property 이름과 같은 이름을 가진 빈 객체가 존재할 경우
이름이 같은 빈 객체를 주입받는다.
이럴때 @Qulifier에 한정자를 설정해줘서 해결한다. -->

<!-- [Spring] DAO, DTO, VO, BO
-> DAO (Data Access Object) : 데이터 사용기능 담당 클래스이다.
DB 데이터 조회나 수정, 입력, 삭제와 같은 로직을 처리하기 위해 사용한다.
CRUD의 기능을 한다고 보면 된다.
DAOInterface / DAOImplement 로 구분지어 명세와 구현 분리하며 개발한다.
-> DTO (Data Transfer Object) : 데이터 저장 담당 클래스이다.
Controller, Service, View 처럼 계층 간의 데이터 교환을 위해 쓰인다.
로직을 갖고 있지 않으며 순수한 데이터 객체이며 getter, setter 메소드만 갖고 있다.
-> VO (Value Object) : DTO와 마찬가지로 데이터 저장 담당 클래스이다.
DTO와 달리 값을 위해 쓰이는 객체이므로 Read-Only 속성을 갖고 있어 getter 기능만을 포함하고있다.
-> BO (Business Object) : VO와 유사하나 비즈니스 로직을 포함하고 있다.
-->

<!-- 추상메서드 -->
<!-- 여러 객체에 공통되는 사항을 추출하여 부모 클래스에 선언 및 구현하고 자식클래스에는 특징을 구현하여 기능을 확장한다.
부모클래스에서 공통 부분 구현과 설계가 완료되면 자식 클래스에서 상속 받아 기능 확장시 이롭다.
추상 클래스 선언시 자식 클래스에서 추상매서드를 반드시 구현하도록 강요한다. 이는 프로그램의 표준화 정도를 높인다.
공통 사항이 한 곳에서 관리되어 개발 및 유지보수에 용이하다.
추상 클래스 및 추상 메서드를 선언하기 위해서는 class, return type 앞에 abstract를 선언해 주면 된다.
추상 메서드를 포함하지 않아도 abstract class로 선언하면 추상 클래스로 인지되기 때문에 상속을 통해 인스턴스를 생성해야 한다.
추상 클래스는 아직 구현되지 않은 기능을 포함한 클래스이다.  미 구현된 클래스는 인스턴스화 시킬 수 없다.
다른 클래스에서 추상클래스를 상속하여 미 구현된 메서드를 오버라이딩하여 재구현하고 자식 클래스를 인스턴스롸 하여 사용해야 한다. -->

<!-- 클래스, 객체, 인스턴스 -->
<!-- 클래스 (Class) -->
<!-- 객체를 만들어 내기 위한 설계도 혹은 틀. 연관되어 있는 변수와 메서드의 집합 -->
<!-- 객체(Object) -->
<!-- 소프트웨어 세계에 구현할 대상. 클래스에 선언된 모양 그대로 생성된 실체.
클래스의 인스턴스라고도 부른다. 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
OOP의 관점에서 클래스 타입으로 선언되었을때 '객체'라고 부른다. -->
<!-- 인스턴스(Instance) -->
<!-- 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체. 객체를 소프트웨어에 실체화 한 것.
실체화 된 인스턴스는 메모리에 할당된다. 인스턴스는 객체에 포함된다고 볼 수 있다.
OOP관점에서 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
추상적인 개념과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다. -->

<!-- final 클래스, final 메소드, final 필드 -->
<!-- final 클래스 -->
<!-- Class 명 앞에 final이 붙은 클래스. 상속이 불가능하다.
Java에서는 이론상 중요한 Class의 sub class를 만들어 sub class가 시스템을 파괴하도록 할 수 있기 때문에
시스템에 중요한 class는 final로 선언한다.
상속 받을 수 없기 때문에 내부의 모든 method는 overriding (재정의) 될 수 없다. -->
<!-- final 메소드 -->
<!-- 부모클래스에서 정의한 특정 method기능을 그대로 쓰게 하고 싶을때 사용한다. -->
<!-- final 필드 -->
<!-- 한번 초기화 하면 더이상 그 값을 변경할 수 없게된다. 따라서 상수화를 위해 사용된다.
변하지 않는 값을 많은 곳에서 사용할 때 상수화를 하면 메모리를 아낄 수 있다. -->

<!-- enum 클래스 -->
<!-- enum 클래스는 열거체(enumeration type)으로 JDK 1.5버전 이상에서만 사용이 가능하다.
클래스처럼 보이게 하는 상수이며 서로 관련있는 상수들끼리 모아 상수들을 정의하는 것.
열거형으로 선언된 순서에 따라 0부터 index값을 가진다. (순차적 증가)
enum 열거형으로 지정된 상수들은 모두 대문자로 선언한다.
열거형 변수들을 선언한 후 마지막에 세미콜론을 찍지 않는다. 단, 상수와 특정 값을 연결시킬 경우
마지막에 세미콜론을 붙여줘야 한다. -->
<!-- final로 상수를 만들때는 상수값이 변경되면 클라이언트도 다시 컴파일 해야해서 프로그램이 깨지기 쉬움.
enum 클래스는 이런 문제점을 해결해준다. -->

<!-- SSO (Single Sign-On) : 통합인증 -->
<!-- 한번의 인증 과정으로 여러 컴퓨터 상의 자원을 이용 가능하게 하는 인증기능.
하나의 아이디로 한번의 인증을 거쳐 여러 어플리케이션을 사용할 수 있는 것.
대표적으로 구글 아이디 하나로 구글 드라이브 G메일 구글 포토 등을 쓸 수 있는 것. -->
<!-- 장점
ID 및 PW 개별 관리의 위험성 해소 , 중앙 집중 관리를 통한 효율적 관리 가능, 운용비용 감소
-> 서비스별로 ID 및 PW를 달리 하여 각 서버별로 관리하게 되면,
각각의 서버에 보안 솔루션이 각각 적용되어야 하므로 관리하기가 까다롭고 신경써야 할 것이 많아지게 된다.
사용자 편의성 증가
-> Admin뿐만 아니라, User 역시 한 ID 및 PW만 기억하고,
한번의 인증으로 여러 서비스를 이용할 수 있기 때문에 번거로움이 크게 줄어든다.  -->
<!-- 단점
SSO 자체가 단일 실패 지점(SPoF)이 된다
-> ID 및 PW가 노출될 시 전체 시스템이 위험해 지며,
이는 SSO 서버 침해의 경우도 마찬가지로 모든 서버의 보안 침해가 가능해진다.
각각의 사이트마다 보안 수준이 다르면 , 보안에 문제가 생길 수 있다. -->

<!-- FTP (File Transfer Protocol) -->
<!-- 파일을 전송하는 통신 규약. 원격에 있는 서버에 파일을 주고 받을 때 사용하는 인터넷 통신 규약인데
내 컴퓨터에 있는 파일을 계정을 제공하는 서버로 서로 이동 시키는 것 -->
<!-- SFTP -->
<!-- FTP의 보안 문제점을 방지하기 위해 나온것. 
일반적인 FTP와 달리 PC와 서버간의 테이터 전송을 암호화 하기 때문에 해킹이나 보안상의 문제점을 방지,
안전한 호스팅 서버를 이용할 수 있습니다. -->

<!-- JAVA 이미지 회전 -->
<!-- BufferedImage 및 Graphics2D.rotate()사용 -->
<!-- BufferedImage 객체를 매개변수로 수신하고
회전된 BufferedImage 객체를 반환하는 함수 rotateImage()를 만듭니다.
rotateImage()에서 getWidth(), getHeight() 및 getType() 메서드를 사용하여
이미지의 너비, 높이 및 유형을 가져옵니다. 
BufferedImage() 생성자를 호출하고 세 변수를 인수로 전달하면  BufferedImage 객체 newImageFromBuffer를 반환합니다.
Graphics2D 객체 graphics2D를 반환하는 createGraphics() 메서드를 사용하여 회전된 새 이미지를 만듭니다. 
이 객체를 사용하여 세 개의 인수를 취하는 rotate() 함수를 호출합니다. 
첫 번째는 Math.radians(90)를 전달하여 이미지를 90도 회전할 때 이미지를 회전하는 각도이고, 
두 번째 및 세 번째 인수는 x 및 y 좌표입니다.
마지막으로 graphics2D.drawImage()를 호출하여 네 개의 인수인 BufferedImage 객체, 적용할 필터, x 및 y 좌표를 사용하는 회전된 이미지를 그립니다. 
그런 다음 newImageFromBuffer 객체를 반환합니다.
main 함수에서 File을 사용하여 파일을 읽은 다음 ImageIO.read()를 사용하여 BufferedImage 객체로 변환합니다. 
rotateImage() 함수를 호출하고 반환된 BufferedImage 객체를 전달하고 회전된 BufferedImage 객체를 저장합니다. \
BufferedImage 객체를 사용하는 File 및 ImageIO.write()를 사용하여 저장할 새 파일을 생성해야 합니다. 
확장자는 빈 파일의 위치입니다.-->
<!-- Affin 변환 사용 -->
<!-- rotateImage() 함수에서 new File()을 사용하여 이미지를 읽고 ImageIO.read()를 사용하여 BufferedImage 객체로 변환합니다. 
그런 다음 원본 이미지의 속성을 유지하는 또 다른 BufferedImage 개체를 만들고 출력이라고 합니다. 
다음으로 rotateImageClockWise() 메소드를 호출하고 AffineTransorm 클래스의 객체를 반환하는 원래 BufferedImage를 전달합니다.
rotateImageClockWise()는 이미지를 수신하고 높이와 너비를 가져옵니다. 
우리는 AffineTransform 객체 affineTransform을 만들고 그것을 사용하여 rotate() 메소드를 호출합니다. 
‘rotate()‘에서 세 개의 인수를 전달합니다. 
첫 번째는 라디안으로 측정된 회전 각도입니다. 
여기에서 ‘Math.PI / 2’를 전달합니다. 마지막 두 인수는 이미지 너비와 높이의 절반인 x 및 y 좌표입니다.
이제 이미지가 회전할 때 두 개의 인수를 사용하는 translate() 함수를 사용하여 새 좌표에서 이미지를 변환합니다.
x 방향으로 회전할 거리와 y 방향으로 회전할 거리입니다.
(imageWidth - imageHeight) / 2를 사용하여 x 및 y 인수를 계산합니다.
이미지를 시계 반대 방향으로 회전하려면 rotateImageClockWise()
대신 rotate()에서 rotateImageCounterClockwise() 메서드를 호출할 수 있습니다. -->

<!-- 스트림(Stream) -->
<!-- 데이터가 출발지에서 도착지로 단일 방향으로 흘러가는 개념
프로세스가 데이터의 도착지라면 입력 스트림 (InputStream)
프로세스가 데이터의 출발지라면 출력 스트림 (OutputStream) 이라고 불린다.
기준은 항상 프로그램이다. -->
<!-- 스트림은 꼭 사용이 끝나면 close() 메소드로 스트림을 닫아 자원을 해제해야한다. 
이는 try with resources 문법으로 간략하게 실행할수도 있다. -->
<!-- 바이트 기반 스트림 -->
<!-- InputStream의 주요 메서드
read() : 일력 스트림으로 부터 1 바이트를 읽고 4 바이트 int 타입으로 리턴한다.
따라서 int 타입의 4 바이트 중 마지막 1 바이트에만 데이터가 저장 된다.
더이상 읽을 데이터가 없다면 -1을 리턴한다. 
read(byte[] b) : 파라미터로 전달한 바이트 배열에 스트림으로부터 읽어드린 데이터를 저장한다.
반환 값은 읽어들인 데이터의 바이트 수 이다.
read(byte[] b, int off, int len) : 주어진 배열 b 의 인덱스 off부터 시작하여 len 개의 데이터를 저장한다.-->
<!-- OutputStream의 주요 메서드
write(int b) : 출력 스트림으로 단일 바이트를 출력한다.
파라미터가 int인데 int는 4 바이트 이므로 마지막 1바이트만 전송된다. 
write(byte[] b) : 파라미터로 전달된 바이트 배열을 출력 스트림으로 전송한다.
write(byte[] b, int off, int len) : 주어진 바이트 배열에서 off 번째부터 len 개의 데이터를 전송한다. -->
<!-- 문자 기반 스트림 -->
<!-- 최상위 문자 기반 스트림 클래스, Reader와 Writer
Reader 는 문자 기반 입력 스트림 최상위 추상 클래스이고, 
Writer 는 문자 기반 출력 스트림 최상위 추상 클래스이다. -->
<!-- Reader 주요 메소드
read() :  입력 대상으로 부터 2바이트의 데이터를 읽고, 4바이트인 int 형으로 반환한다. 
InputStream 처럼 더이상 읽을 데이터가 없다면 -1을 반환한다. 
read(char[] cbuf) : 파라미터로 전달된 char 배열에 읽어온 데이터를 저장한다. -->
<!-- Writer 주요 메소드
write(int c) , write(char[] cbuf) , write(char[] c, int off, int len) 등이 있다. 
앞서 설명한 여러 스트림 클래스의 사용법과 동일하므로 코드는 생략 
write(String str), write(String str, int off, int len) : 편의를 위해 char 의 배열이 아니라
String 타입도 전달할 수 있도록 설계되었다-->

<!-- View Resolver (뷰 리졸버) -->
<!-- 컨트롤러에서 전달받은 View의 이름을 토대로 jsp를 찾아 선택하고, 
jsp 데이터를 분석해 응답 결과를 만들어 전달하는 요소.
View Resolver에 의해 jsp가 실행되고, 응답 결과가 만들어진다.
Controller에서 View를 지정할 때 View Resolver가 사용할 데이터를 Request영역에 저장할 수 있다. -->

<!-- Spring Framework의 작동 원리
    1.사용자의 요청을 Dispatcher Servlet이 받아들인다.
    2.사용자의 요청정보를 분석해서 어떤 컨트롤러를 사용할 것인지 결정
    3.해당 컨트롤러에게 사용자 요청에 대한 정보가 담겨있는 request객체를 전달
    4.컨트롤러는 요청된 작업이 완료된 후 사용자에게 응답 할 뷰(jsp)를 완성하기 위한 정보와, 사용 할 jsp가 무엇인지에 대한 정보(=Request객체)를 ModelAndView 객체에 담는다.
    5.ModelAndView를 전달받은 DispatcherServlet은 그 안에 들어있는 View Name을 추출해서 View Resolver로 전달
    6.View Resolver는 그 데이터를 분석해서 해당하는 jsp를 선택 후, jsp를 분석해서 View라는 객체를 만들어서 다시 Dispatcher Servlet으로 전달
    7.DispatcherServlet은 이러한 정보를 이용해서 jsp를 완성시킨 다음에 완성된 html코드를 사용자에게 보여준다. 
-->

<!-- Spring Boot 에서 messages.properties를 이용한 다국어 처리 -->
<!-- 기본 제공할 언어에 대해서 messages.properties에 정의하고 
messages_ko.properties와 같이 파일을 생성하여 언어에따는 메세지를 관리한다.
messages_en_US.properties 와 같이 국가에 따른 분류 파일도 추가로 설정할 수 있다. -->

<!-- .properties -->
<!-- 응용 프로그램의 구성 가능한 파라미터들을 저장하기 위한 자바 관련 기술을 사용하는 파일들을 위한 확장자.
각 파라미터는 문자열등의 일부로 저장되며 , 문자열은 파라미터의 이름 (키)을 저장하며, 다른 하나는 값을 저장.
HashTable을 상속받아 구현한 컬렉션의 한 종류로서
key(object), value(object) 형태가 아니라 key(string), value(string) 형태로 저장하는 보다 간단한 컬렉션
사용 이유: 개발자들이 소스에 직접 값을 하드 코딩하는 경우가 종종있다.
하지만 이렇게 하드 코딩할 경우 하드 코딩된 변수가 많아지면 유지보수도 힘들어질 뿐더러
암호화에 사용되는 key값들을 하드코딩하는 경우 보안적인 측면에서 안전하지 못하다.
따라서 이러한 하드코딩이 필요한 변수들을 보통 properties 파일로 빼놓고 관리한다. -->

<!-- SEED256 for JAVA -->
<!-- SEED란 한국 인터넷 진흥원에서 개발한 암호 알고리즘이다.
그 중 SEED25은 2009년에 개발된 256비트이며 양방향(대칭) 알고리즘으로 주민등록번호나 전화번호,
계좌와 같은 복호화가 필요한 데이터를 암호화하는데 사용할 수 있다.
암호화되어야 할 문자는 항상 16byte여야 하기 때문에
암호화 되어야 할 문자가 16byte보다 작으면 Ansi X.923 Padding을 이용해서 16byte로 만들어서 암호화하고,
16byte가 넘어가면 16byte씩 자르고 마지막에 모자란 byte를 역시 Ansi X.923 Padding을 이용해서 16byte를 만들어야 한다. -->
<!-- Encrypt(String password) 함수 -->
<!-- 전달받은 매개변수를 암호화 하여 Hash값을 리턴한다. -->
<!-- Decrypt(String hash) 함수 -->
<!--  Encrypt 함수를 사용하여 만들어진 Hash값을 다시 원래의 매개변수로 복호화한다. -->
<!-- padding -->
<!-- SEED, ARIA, AES 등 암호화 알고리즘은 지정된 block size 단위로 암호화 복호화를 수행한다.
암복호화 하려는 입력 데이터를 block Size 단위로 쪼개어 반복 호출하여 전체 데이터를 암복호화 할 수 있다.
입력 데이터가 block Size의 배수가 아닌 경우 부족한 만큼 데이터를 추가하는 것을 Padding 이라 한다.
데이터를 추가하는 방식에 따라 PKCS5, PKCS7, X923 등 구분 된다. -->
<!-- X923 -->
<!-- X923 패딩은 block size의 부족한 만킁을 0값 으로 채우며 마지막 바이트는 padding된 바이트 수를 기록한다. -->

<!-- Spring - XML Collection -->
<!-- Property Type -->
<!-- 
    <value>요소를 사용하여 key = value 형식으로 지정할 수 있습니다.
    <props>요소를 사용하여 내부에 <prop>요소의 key 특성과 value 형식으로도 사용할 수 있습니다.
    -->
<!-- List Type -->
<!-- 
    <list> 요소를 사용하여 값을 지정할 수 있습니다.
    <list>의 특성 중 value-type을 사용하여 생성자 인자가 받는 요소의 형식을 지정할 수 있습니다.
    value-type은 선택사항이며, value-type 특성을 지정하면 스프링 컨테이너는 등록된 속성 편집기를 사용해
    값을 value-type 특성으로 지정된 형식으로 변환하며, 필요한 경우 매개변수화 된 List 형식에서 허용되는 형식으로 다시 변환할 수 있습니다.
    value-type특성을 지정하지 않으면 스프링 컨테이너는 간단히 등록된 속성 편집기를 사용해
    값을 매개변수화 된 List 형식에서 허용되는 형식으로 변환합니다.
-->
<!-- Map Type -->
<!-- 
    <map>요소를 사용하여 값을 지정할 수 있습니다.
    key-type, value-type 특성을 지정하여 허용하는 키와 값의 형식을 지정할 수 있습니다.
-->
<!-- Set Type -->
<!-- 
    <set> 요소를 사용하여 값을 지정할 수 있습니다.
    value-type 특성에는 set에 허용되는 형식을 지정할 수 있습니다.
 -->