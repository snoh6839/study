<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- 
-//W3C//DTD XHTML 1.0 Transitional//EN은 XHTML 1.0 Transitional 버전을 의미합니다. 
이는 XHTML(Extensible Hypertext Markup Language)이라는 XML 기반의 HTML 버전으로, 
웹 브라우저에게 이 문서가 XHTML 1.0 Transitional 규격을 따르는 것임을 알려줍니다.

"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"는 
DTD(Document Type Definition) 파일의 경로를 지정하는 것으로, 
XHTML 1.0 Transitional 버전의 DTD 파일을 참조합니다. 
DTD 파일은 해당 HTML 버전의 문서 구조와 요소들의 정의를 포함하고 있습니다.

이 선언문은 웹 브라우저가 문서를 올바르게 해석하고 렌더링하는 데 도움을 주는 역할을 합니다. 
또한 웹 표준을 준수하는 것으로서, 웹 브라우저의 호환성과 웹 개발의 통일성을 유지하는 데 도움을 줍니다. -->


<!-- overloading vs overriding -->
<!-- 오버로딩 : 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 말한다.
오버라이딩 : 상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것을 말한다. -->


<!-- @RequestMappin -->
<!-- 어노테이션 기반의 컨트롤러를 지원하는 핸들러 매핑과 어댑터
-> 자바에서 Annotation은 코드 사이에 주석처럼 쓰이며 특별한 의미, 
기능을 수행하도록 하는 기술이다. -
프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.
-> 핸들러 매핑 / 핸들러 어댑터를 통래 실제 핸들러가 호출 -->
<!-- RequestMapping의 인터페이스
RequestMappingHandlerMapping: RequestMapping의 핸들러 매핑
-> HandlerMapping: 특정 Controller를 찾을 수 있어야 함
RequestMappingHandlerAdapter: RequestMapping의 핸들러 어댑터
-> HandlerAdapter: Handler Mapping을 통해 찾은 Handler를 실행 할 수 있음
-->
<!-- 동작방식 -->
<!-- HTTP Request를 통해 요청
핸들러 매핑 탐색: HandlerMapping을 순회하며 해당하는 RequestMappingHandlerMapping 반환
핸들러 어댑터 조회: HandlerAdapter.supports()를 순서대로 호출하며 처리할 수 있는 핸들러 어댑터를 탐색
핸들러 어댑터 실행: RequestMappingHandleAdapter로 실제 핸들러 호출
뷰 리졸버 실행: 논리주소를 싱제 물리 주소로 반환
view: 뷰 랜더링
-->
<!-- 논리주소와 물리주소
-> 논리 주소는 CPU와 실행중인 프로그램 입장에서 바라본 주소로 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소를 의미
-> 물리 주소는 메모리 입장에서 바라본 주소, 말 그대로 정보가 실제로 저장된 하드웨어상의 주소를 의미
-->
<!-- 뷰 랜더링 (뷰 리졸루션)
컨트롤러에서는 , 직접적으로 브라우저에 랜더링하는 HTML을 생성해내는 메소드가 없음
대신 랜더링을 위한 데이터를 모델에 담아 뷰에 전달하는 역할을 함. 뷰의 논리적 이름만 전달.
ViewResolver는 뷰의 이름과 Locale을 넘겨받고 View를 리턴해줌
View는 모델을 전달받은 후 서블릿 요청과 응답 객체를 받아 결과를 랜더링 해줌
-->

<!-- XXS (Cross Site Scripting) 공격 -->
<!-- 게시판이나 웹 메일 등에 자바 스크립트와 같은 스크립트 코드를 삽입 해
개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격.
크게 Reflected XSS 와 Stored XSS 그리고 DOM Based XSS 세가지로 분류 할 수 있다.
-->
<!-- Reflected XSS 
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 URL을 사용자에게 노출 시킨다.
사용자가 해당 URL을 클릭할 경우, 취약한 웹 사이트의 서버에 스크립트가 포함 된 URL을 통해
Request를 전송하고 , 웹서버에서는 해당 스크립트를 포함한 Response를 전송하게 된다.
-->
<!-- Stored XSS
게시판에 스크립트를 삽입하는 공격 방식
공격자는 게시판에 스크립트를 삽입한 후 공격 대상자가 해당 게시글을 클릭하도록 유도한다.
공격자가 미리 XSS 공격에 취약한 사이트를 탐색하고
XSS 공격을 위한 스크립트를 포함 한 게시글을 웹 사이트에 업로드한다.
게시글의 URL을 사용자에게 노출하고 사용자가 게시글을 확인함으로써
URl에 대한 요청을 서버에 전송하게 된다.
웹 서버에서 스크립트를 포함한 Response를 전송하며 공격이 수행된다.
-->

<!-- dextupload -->
<!-- 윈도우 서버는 리눅스 서버의 아파치와 다르게 파일을 업로드 하기위해서 업로드 컴포넌트가 필요합니다.  --> 
<!-- 업로드 컴포넌트 --> 
<!-- 웹 환경에서 브라우저를 ㅌㅇ해 웹서버로 파일을 전송할 수 있도록 해주는 것
실행 환경에 따라 클라이언트 제품과 서버 제품으로 구분됩니다. -->
<!--  DEXTUpload 란? --> 
<!-- 웹브라우저로부터 웹 서버의 파일업로드 기능을 지원하는 HTTP프로토콜 기반의 
    서버측 컴포넌트컴포넌트(Component)로 윈도우 플랫폼에서 IIS로 호스팅되는 
    모든 웹사이트에서 사용할 수 있습니다.
-->

<!-- AOP (Aspect Oriented Programming) 관점 지향 프로그래밍 -->
<!-- 관점지향: 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고
    그 관점을 기준으로 각각 모듈화 하는 것 -->
<!-- 모듈화: 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것 -->
<!-- AOP에서 각 관점을 기준으로 로직을 모듈화 한다는 것은 
코드들을 부분적으로 나누어서 모듈화 하겠다는 의미이다.
이때 소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들을
흩어진 관심사(Crosscutting Concerns)라 부른다. 
이 흩어진 관심사를 Aspect로 모듈화 하고 핵심적인 비즈니스 로직에서 분리하여
재사용 하겠다는 것이 AOP의 취지이다.-->
<!-- AOP의 주요 개념
-> Aspect: 흩어진 관심사를 모듈화 한것. 주로 부가기능을 모듈화함.
-> Target: Aspect를 적용하는 곳 (Class, Method ...)
-> Advice: 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
-> JointPoint: Advice가 적용 될 위치, 끼어 들 수 있는 지점.
매서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 다양한 시점에 적용 가능
-> PointCut: JointPoint의 상세한 스펙을 정의한 것. 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있다.
-->
<!-- 스프링 AOP 특징 -->
<!-- 프록시 패턴 기반의 AOP구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서다. 
스프링 빈에만 AOP가 적용 가능하다.
모든 AOP기능을 제공하는 것이 아닌 스프링 IOC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 지원하는 것이 목정
(중복 코드 , 프록시 클래스 작성의 번거로우ㅜㅁ, 객체들 간 관계 복잡도 증가)-->

<!-- dispatcher-servlet -->
<!-- JAVA Servlet은 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 서블릿이라 불린다. 
자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
즉, 서블릿은 클라이언트 요청을 처리하고, 그 결과를 반환하는 웹 프로그래밍 기술이다.
-->
<!-- 디스패처 서블릿(Dispatcher Servlet) -->
<!-- 디스패처 서블릿 또한 서블릿의 일종으로 가장 먼저 요청을 받고 적절하게 처리해줄 컨트롤러를 찾아서
정해주는 역할을 한다. 
디스패처 서블릿은 HttpServlet을 상속한다.
스프링 MVC의 중앙 서블릿이며 어플리케이션으로 오는 모든 요청을 핸들링하고 공동작업을 처리해준다.
실제 작업(비즈니스 로직, 예외처리 등)은 위임 컴포넌트를 통해 수행된다.
디스패처 서블릿을 프론트 컨트롤러 라고도 부른다.
프론트 컨트롤러는 서블릿 컨테이너 맨 앞에서 모든 요청을 받아 처리해주는 컨트롤러를 의미한다.
서블릿이기 때문에 정적 자원과 동적 자원을 따로 처리 할 수 있다.
디스패처 서블릿에서 요청을 처리할 컨트롤러를 먼저 찾고, 
컨트롤러가 없을땐 2차로 설정된 정적 자원을 탐색한다.
이를 통해 효율적인 리소스 관리가 가능해진다.
-->
<!-- 디스패처 서블릿 설정 방법 -->
<!-- 자바나 web.xml을 통해 등록 및 초기화 되어야 사용 가능하다.
톰캣 등 서블릿 컨테이너를 통해 디스패처 서블릿의 생명주기를 관리하는 것이 일반적이다. 
-->
<!-- 구조 -->
<!-- Sevlet Container
서블릿은 스스로 동작하지 않는다. 보통 서블릿을 관리할 서블릿 컨테이너(톰캣 등)를 사용한다.
서블릿 컨테이너는 싱글톤인 서블릿 객체의 생명주기를 관리한다.
또한 웹서버와 소켓으로 통신하며, 클라이언트의 요청을 받고 응답을 보내준다.
멀티 쓰레드 처리도 지원한다. -->
<!-- WebApplicationContext
디스패쳐 서블릿은 Servlet WebApplication을 생성하고 보통 Root WebApplicationContext를 생성한다. 
서블릿 WebApplicationContext안에는 ServletContext와 연관된 Servlet링크들이 있다.
Controller , ViewResolver, HandlerMapping 등이 이 안에 있다.
RequestContextUtils의 정적 메소드들을 사용해 어플리케이션이 WebApplication을 조회할 수 있다.
Root WebApplicationContex 가 있는 경우 infra bean이 이 안에 들어간다.
Repository, Service 빈 등이 인프라 빈이다.
WebApplicationContext 설정은 java나 web.xml을 통해 할 수 있다.
-->
<!-- 스페셜 빈 (Special Bean) -->
<!-- 디스패처 서블릿은 요청을 처리하기 위해 위임 컴포넌트에 실제 작업을 맡긴다. 
이런 위임 컴포넌트를 스페셜 빈(Special Bean)이라고도 부른다.
스페셜 빈은 프레임워크 계약을 구현하는 스프링 관리 객체 인스턴스를 의미한다.
쉽게 말하면 스프링에서 제공하는 주요 빈들이다.
스페셜 빈 들마다 제공되는 일반적인 설정들이 있지만 사용자가 임의로 재정의하거나 교체가 가능하다.
-->
<!-- 스페셜 빈 종류
handlerMapping: 요청을 처리할 컨트롤러를 찾는다.
handlerAdapter: 요청을 컨트롤러로 전달한다.
handlerExceptionResolver: 요청에 대한 예외 발생 (핸들러 매핑 도중, 컨트롤러 실행도중)시 처리해 준다.
viewResolver: 리턴값에 대한 뷰 컴포넌트를 반환한다. 
string으로 뷰 이름을 전달받았을 때  이를 modelAndView등의 객체로 반환한다.
LocaleResolver: Locle을 결정한다.
-> Locale: 유저의 언어, 지역, 출력형식 등을 정의하는 문자열
MultipartResolver: 멀티파트 파일 업로드를 처리해준다.
-> Multipart: HTTP응답의 바디를 여러 파트로 나눠서 보내줄 때의 파일 형식을 의미한다.
-->
<!-- 작동방식 -->
<!-- 클라이언트 요청을 디스패처 서블릿이 받는다. 이때 filter를 경유할 수 있다.
요청 정보를 보고 Servlet WebApplicationContext안에서 HandlerMapping을 통해 요청을 위임할 컨트롤러를 검색해 찾는다.
찾은 컨트롤러로 요청을 위임할 HandlerAdapter를 찾는다. 이때 Interceptor preHandle이 실행된다.
HandlerAdapter가 컨트롤러로 요청(HttpRequest)을 위임한다.
Argument Resolver가 파라미터를 처리해 컨트롤러로 보낸다.
컨트롤러는 Root WebApplicationContext 속 Service, Repository 등을 호출해가며 비즈니스 로직을 처리한다.
컨트롤러 매소드에서 최종적인 반환값(Response Entity)이 리턴된다.
리턴값에 대해 Interceptor postHandle이 실행된다.
핸들러 어댑터 리턴값을 viewResolver에 전달한다.
viewResolver가 View를 검색하고 찾은 View에 응답을 전달한다.
이후 Interceptor afterCompletion이 실행된다.
디스패처 서블릿에서 View로부터 받은 응답을 클라이언트로 반환해준다. -->

<!-- html 4 / html 5 -->
<!-- html 5로 넘어오면서 문법이 명확하고 간략해 졌다.
멀티미디어 요소 video 및에 audio 추가. html 4 까지 Sliverlight, flash등의 지원이 필요했었다.
사용자 위치 식별 액세스 추가. GeoLocation을 이용하여 보다 간단하게 사용자 위치 액세스 가능
Client 측면의 저장소(WebStorage) html4에서는 browser cache를 이용하여 데이터를 저장했다.
html 5에서는 javascript 인터페이스를 통해 web sql 데이터베이스 응용프로그램 사용이 가능하다.
Client, Server에 WebSocket 통신 추가. html4에서 웹 소켓이 없어, streaming, polling을 통해 데이터 교환을 했다.
html4, javascript가 동일한 thread에서 실행되던 것을 html 5 부터 브라우저 인터페이스를 별도로 실행시킬 수 있다. -->

<!-- smart editor 2. last -->
<!-- 네이버에서 제공하는 웹상 게시판 글 편집기 -->

<!-- 상속 -->
<!-- extends -->
<!-- 부모에서 선언 / 정의를 모두 하며 자식은 메소드 / 변수를 그대로 사용할 수 있다.
일반 클래스의 상속과 abstract 클래스 상속에 사용된다.
클래스 한개만 상속 받을 수 있다.
-->
<!-- implements (인터페이스) -->
<!-- 부모 객체는 선언만 하며 정의는 자식에서 오버라이딩 해서 사용해야함 
자바는 다중 상속을 지원하지 않기 때문에 나온 것 = 여러개 사용이 가능하다.
설계 목적으로 사용 가능하다.
inerface 상속에 사용된다.
class가 interface를 사용할때 써야하지만 interface가 class를 사용할 땐 쓸 수 없다.
implemens한 클래스는 implements의 내용을 다 사용해야 한다.
-->
<!-- abstract
extends와 interface 혼합, extends 하되 몇개는 추상 메소드로 구현되어 있음
-->

<!-- 스프링 인터셉터 -->
<!-- 스프링 MVC 프레임워크에서 HTTP 요청을 가로채어 처리하는 컴포넌트
클라이언트의 요청이 컨트롤러로 전달되기 전에 사전 작업을 수행하거나
컨트롤러 실행 이후에 사후 작업을 수행할 수 있습니다.
즉, 서버에 들어온 Request객체를 컨트롤러 핸들러(url에 매핑되어있는 매서드)로 도달하기 전에 낚아채서
개발자가 원하는 추가적인 작업을 한 후 핸들러로 보낼 수 있도록 해주는 것이 인터셉터입니다. -->
<!-- 전역적인 작업처리
스프링 인터셉터는 여러 컨트롤러에서 공통으로 처리해야 하는 작업을 중앙에서 관리할 수 있습니다.
예를들어 인증이나 권한검사, 로깅 등과 같은 전역적인 작업을 인터셉터에서 처리할 수 있습니다.
이는 코드의 중복을 줄이고 유지보수성을 향상시키는데 도움을 줍니다. -->
<!-- 요청 처리 제어
인터셉터는 HTTP 요청 전후의 흐름을 제어할 수 있습니다.
클라이언트의 요청이 컨트롤러에 도달하기 전에 사전 작업을 수행하거나,
컨트롤러의 실행 이후에 사후 작업을 수행하는 등의 제어가 가능합니다.
이를 통해 요청의 전처리나 후처리를 담당할 수 있습니다. -->
<!-- 유연한 설정
스프링 인터셉터는 다양한 방식으로 설정할 수 있습니다.
XML, 애노테이션, JavaConfig 등의 설정 방법을 사용하여 인터셉터를 관리할 수 있습니다. -->
<!-- 다양한 용도에 활용 가능
스프링 인터셉터는 다양한 용도로 활용할 수 있습니다.
주로 인증과 권한 검사, 로깅, 트랜잭션 관리 등의 전역적인 작업을 처리하는데 사용되지만,
요청처리의 어떤 단계에서든 원하는 작업을 수행할 수 있습니다. -->
<!-- 다중 인터셉터 지원 -->
<!-- 개발자가 특정 Controller의 핸들러가 실행되기 전이나 후에 추가적인 작업을 원할때 사용합니다.
스프링 인터셉터를 사용함으로써 코드의 중복을 줄이고 관심사를 분리하여 개발자는 핵심 비즈니스 로직에 집중할 수 있습니다.
또한 유연한 설정 방식과 다중 인터셉터 지원으로 인해 개발자는 프로젝트의 요구에 맞게 인터셉터를 활용할 수 있습니다. -->
<!-- Spring Interceptor의 작동원리
-> HandlerMapping 검색 : 클라이언트의 요청이 들어오면 먼저 HandlerMapping이라는 Spring 컴포넌트가
요청과 관련된 적절한 컨트롤러를 찾는다. 
HandlerMapping은 요청 URL을 기반으로 컨트롤러를 선택하는 역할을 한다.
-> Intercepter 체인 생성 : HandlerMapping은 해당 컨트롤러와 연결된 Interceptor 체인을 생성한다.
Interceptor 체인은 여러개의 Interceptor 객체로 구성 될 수 있으며, 각각의 Interceptor는 요청을 가로 채고 처리하는 역할을 수행한다.
-> PreHandle 매서드 호출 : PreHandle 매서드 실행 후, HandlerMapping은 적절한 컨트롤러를 호출합니다.
컨트롤러는 클라이언트 요청을 처리하고 결과를 반환합니다.
-> PostHandle 매서드 호출 : 컨트롤러가 실행된 후에는 Interceptor 체인의 각 Interceptor의 PostHandle 매서드가 호출됩니다.
PostHandle 매서드는 컨트롤러의 실행 결과를 가로채고, 후속 작업을 수행할 수 있습니다.
-> View 랜더링 및 응답 : PostHandle 매서드 실행 후, HandlerMapping은 적절한 View를 랜더링하여 클라이언트에게 응답을 보냅니다.
-> AfterCompletion 메서드 호출 : 응답이 완료되면 Interceptor 체인의 각 Interceptor의 AfterCompletion 매서드가 호출됩니다.
AfterCompletion 매서드는 요청 처리가 완료된 후에 실행되며, 리소스 정리나 로깅 등의 작업을 수행할 수 있습니다.
-->
<!-- HandlerInterceptor 인터페이스 -->
<!-- 스프링 인터셉터는 HandlerInterceptor 인터페이스를 구현하여 작성됩니다.
-> preHandle(): 컨트롤러 실행 전에 호출되는 매서드입니다.
요청을 가로채고 사전 작업을 수행할 수 있습니다.
이 메서드가 true를 반환하면 요청은 계속 진행되고 false를 반환하면 요청 처리가 중단됩니다.
-> postHandle(): 컨트롤러 실행 이후에 호출되는 매서드입니다. 컨트롤러의 실행 결과에 대한 후처리 작업을 수행할 수 있습니다.
-> afterCompletion(): 뷰 랜더링까지 안료된 후에 호출되는 매서드입니다. 최종적인 작업 처리를 수행할 수 있습니다.
-->
<!-- 장점 
-> 중앙 집중적인 공통 기능 관리
Interceptor를 사용하면 로그인 체크, 권한 검사, 로깅, 예외 처리 등과 같은 공통적인 기능을 중앙에서 관리할 수 있습니다. 
중복 코드를 제거하고 유지보수성을 향상시킬 수 있습니다.
-> 재사용성과 확장성
Interceptor는 여러 컨트롤러에 적용될 수 있으며, 
Interceptor 체인을 구성하여 여러 개의 Interceptor를 조합할 수 있습니다. 이로 인해 공통 기능을 간편하게 재사용하고, 
필요에 따라 확장할 수 있습니다.
-> 요청 처리 과정 제어
Interceptor는 요청 전(preHandle)과 후(postHandle)에 실행되는 메서드를 제공하여 
요청 처리 과정을 세밀하게 제어할 수 있습니다. 예를 들어, 요청 전에 인증 체크를 수행하거나, 
요청 후에 로깅 작업을 수행할 수 있습니다.
-> 전역 예외 처리
Interceptor를 사용하면 예외 처리를 중앙에서 처리할 수 있습니다. 
예외가 발생하면 Interceptor의 예외 처리 메서드를 활용하여 일관된 방식으로 예외를 처리하고 
사용자에게 적절한 응답을 보낼 수 있습니다. -->
<!-- 단점
-> 성능 영향
Interceptor는 요청과 응답 사이에 위치하므로, 매 요청마다 Interceptor 체인이 실행되어야 합니다. 
Interceptor가 많거나 복잡한 작업을 수행하는 경우 성능에 영향을 줄 수 있습니다. 따라서 Interceptor의 사용은 신중하게 고려되어야 합니다.
-> 컨트롤러와의 결합도
Interceptor는 컨트롤러와 긴밀하게 결합되어 있습니다.
이는 컨트롤러의 변경에 따라 Interceptor도 변경될 수 있음을 의미합니다. 
따라서 Interceptor의 사용은 컨트롤러와의 강한 결합도를 가질 수 있으므로 유지보수에 주의가 필요합니다.
-> 작업의 순서와 조건 제어
Interceptor 체인에서 Interceptor의 실행 순서와 조건 제어를 올바르게 설정해야 합니다. 
잘못된 순서나 조건 설정은 의도하지 않은 동작을 유발할 수 있으므로 주의가 필요합니다.
-> 제한된 범위
Interceptor는 주로 웹 요청을 처리하는 데 사용됩니다. 
따라서 웹 애플리케이션에만 적용 가능하며, 다른 종류의 요청이나 서비스에는 사용할 수 없습니다. -->
<!-- filter, aop와의 비교 -->
<!-- Spring Interceptor
Spring MVC 컴포넌트에 종속적으로 동작합니다. 주로 웹 애플리케이션의 요청과 응답 사이에 위치하여 작업을 수행합니다.
컨트롤러(Controller)에 집중된 기능을 처리하고, 공통 기능을 중앙에서 관리하고 재사용할 수 있습니다.
PreHandle, PostHandle, AfterCompletion 등의 메서드를 제공하여
요청 처리의 다양한 단계에서 작업을 수행할 수 있습니다.
컨트롤러와의 강한 결합도를 가질 수 있으며, 주로 웹 애플리케이션에 사용됩니다. -->
<!-- Filter
Java Servlet 스펙에 정의된 필터(Filter) 인터페이스를 구현하여 동작합니다. 
서블릿 컨테이너에서 동작하는 웹 애플리케이션 전체에 영향을 미칩니다.
웹 애플리케이션의 요청과 응답을 처리하는데 사용됩니다. 
주로 요청과 응답의 헤더 수정, 인코딩 변환, 보안 처리 등을 수행합니다.
DispatcherServlet 이전에 동작하므로 Spring MVC와 독립적으로 동작하며, 여러 개의 서블릿에 적용할 수 있습니다.
Spring Interceptor와 달리 컨트롤러와의 결합도가 낮아서 다양한 웹 애플리케이션에 사용될 수 있습니다. -->
<!-- AOP(Aspect-Oriented Programming)
관점 지향 프로그래밍(Aspect-Oriented Programming)의 개념을 기반으로 동작합니다. 
애플리케이션 전체의 핵심 비즈니스 로직에 공통 기능을 적용하는 데 사용됩니다.
주요한 관심사를 횡단(cross-cutting)하는 방식으로 구현하며, 코드의 흩어진 곳에 횡단 관심사를 분리하여 모듈화합니다.
주요한 관심사를 독립적인 모듈로 구현한 어드바이스(Advice)를 정의하고, 
어드바이스를 적용할 타깃(Target) 객체와 결합시켜 동작합니다.
주로 로깅, 트랜잭션 관리, 보안 등과 같은 공통 기능에 사용됩니다. -->

<!-- ERROR CODE 100 ~ 500 -->
<!-- 우리가 주로보는 400, 403, 404, 500 에러에 대하여
HTTP 400 ERROR : 서버가 요청의 구문을 인식하지 못했다는 뜻으호 문법상의 오류가 있다는 뜻
HTTP 403 ERROR : 서버가 요청을 거부하고 있다는 뜻으로 접근이 금지되었다는 뜻
HTTP 404 ERROR : 서버가 요청한 페이지를 찾을 수 없다는 뜻
HTTP 500 ERROR : 서버에 오류가 발생하여 요청읗 수행할 수 없다는 뜻 -->
<!-- 100 ~ 199 -->
<!-- 100번대 코드들은 클라이언트가 다음에 행동할 정보를 안내합니다.
100 (continue) : 클라이언트에서 첨부문서 (attached document)를 보내기 전에 요청을 보낼때
Expect 헤더에 설정해서 보냅니다.
101 (switching protocol) : 서버가 upgrade헤더에 응답할 수 있고,
다른 플토콜로 전환 한다는 것을 나타냅니다. -->
<!-- 200 ~ 299 -->
<!-- 요청 받은 것이 성공적으로 처리되었음릉 나타냅니다.
200 (ok) : 모든 것이 제대로 처리되었다는걸  나타냅니다.
201 (Created) : 클라이언트의 요청에 대해서 서버가 새로운 문서를 생성하였다는 것을 나타냅니다.
202 (Accepted) : 클라이언트의 요청을 받아 들이기만 했을 뿐 아직 완료되지 않은 상태를 나타냅니다.
204 (No Content) : 새로운 문서가 없어서 브라우저에게 이전 문서를 계속 표시하라고 알려주는 것입니다.
205 (Rest Content) : 새로운 문서가 없더라도 브라우저에서 창을 초기화 하고 문서를 새로 표시한다는 것입니다. -->
<!-- 300 ~ 399 -->
<!-- 파일들이 이동되었을때 쓰이며, 이동하는 위치를 나타내는 Location 헤더가 응답에 포함됩니다.
300 (Multiple Choice) : 요청된 문서가 여러 곳에 있을 때 어떤 문서를 원하는지 묻는 것입니다.
301 (Moved Permanently) : 요청된 문서의 위치가 영구적으로 변했음을 나타내는 것입니다.
302 (Found) : 요청된 문서의 위치가 임시적이라는 것을 나타냅니다.
304 (Not Modified) : 브라우저의 캐시에 들어있는 문서가 최신 문서이니 그것을 그대로 사용하라는 것을 나타냅니다.
305 (Use Proxy) : 요청된 문서를 프록시를 통해서 전송받으라는 것을 나타냅니다. -->
<!-- 400 ~ 499 -->
<!-- 클라이언트 때문에 나타난 오류를 의미합니다.
401 (Bad Request) : 클라이언트에서 잘못된 구문으로 요청하였음을 나타냅니다.
402 (Unauthorized) : 클라이언트가 잘못된 인증정보를 Authorization 헤더에 넣었음을 나타냅니다.
403 (Forbidden) : 클라이언트의 인증 정보에 상관없이 페이지에 대한 접근을 거부한다는 것을 나타냅니다.
404 (Not Found) : 클라이언트가 요청한 자원이 서버에 없다는 것을 나타냅니다.
408 (Request Timeout) : 클라이언트의 요청을 기다릴 수 있는 제한시간이 지났다는 것을 나타냅니다.
410 (Conflict) : 요청된 문서가 사라지고, 새로운 주소를 알 수 없다는 것을 나타냅니다.
413 (Request Entity Too Large) : 요청된 문서가 서버가 다룰 수 있는 문서의 크기보다 큼을 나타냅니다.
415 (Unsupported Media Type) : 요청에 첨부된 문서가 서버가 처리할 수 없는 문서임을 나타냅니다. -->
<!-- 500 ~ 599 -->
<!-- 서버에 의한 오류를 나타냅니다
500 (Internal Server Error) : 서버 내부에 문제가 있음을 나타냅니다.
501 (Not Implemented) : 클라이언트의 요청을 처리하는데 필요한 기능을 서버가 지원하지 않음을 나타냅니다.
502 (Bad Gateway) : 서버가 게이트웨이 역할을 할 때 원격서버로부터 잘못된 응답을 받았음을 나타냅니다.
503 (Service Unavailable) : 서버의 사정으로 응답할 수 없음을 나타냅니다. -->

<!-- Annotation -->
<!-- 코드 사이의 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술
실제 데이터가 아닌 데이터를 위한 데이터로 메타 데이터(meta data)로 불린다. -->
<!-- 어노테이션 용도
컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공.
소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보제공
실행시 (런타임) 특정 기능을 실행하도록 정보제공 -->
<!-- 어노테이션 순서
정의 , 클래스에 배치, 코드 실행중 Reflection을 이용하여 추가 정보 획득하여 기능 실행
-> Reflection : JVM에서 실행되는 애플리케이션의 런타임 동작을 검사하거나 수정할 수 있는 기능이 필요한 경우 사용.
쉽게 클래스의 구조를 개발자다 확인할 수 있고, 값을 가져오거나 매서드를 호출하는데 사용됨. -->
<!-- @ComponentScan -->
<!-- @Component, @Servicce, @Repository, @Controller, @Configuration 어노테이션이 붙은 Bean을 찾아서
Context에 Bean을 등록해주는 어노테이션
-> Bean 등록 방법: @어노테이션을 이용한다 , 파일에 직접 등록한다. 
-> 직접 등록: ApplicationContext.xml 파일에 <bean id = "example" class = "example" /> 
스프링 부트에서 기능을 제공해 주기 때문에 직접 사용할 일이 잘 없음-->
<!-- @Component -->
<!-- 개발자가 직접 작성한 Class를 Bean으로 등록하기 위한 Annotation -->
<!-- @Controller, @Service, @Repository -->
<!--  @Component 어노테이션의 구체화된 형태.
어노테이션을 세분화 함으로써 가독성 측면에서 해당 각각의 어노테이션을 가진 클래스의 역할을 알 수 있게 됨.
-> @Controller : 클라이언트로부터 전달된 데이터를 가공하기 위한 Controller이다.
@RequestMapping(@GetMapping / @PostMapping)을 통해 경로 설정을 하게 된다.
-> @Service : Repository를 통해 DB에 데이터를 가져온 후 컨트롤러에 전달해주는 클래스.
애플리케이션의 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성을 검증하고, 트랜잭션을 처리한다.
레파지토리를 호출하기 때문에 레파지토리에까지 적용되는 @Transactional 애노테이션을 서비스에서 사용한다.
-> @Repository는 해당 클래스가 DB에 접근하는 클래스임을 명시한다. -->

<!-- 의존 객체 자동 주입 (Automatic Dependency Injection) -->
<!-- 스프링 설정 파일에서 혹은 태그로 의존 객체 대상을 명시하지 않아도
    스프링 컨테이너가 자동적으로 의존 대상 객체를 찾아 해당 객체에 필요한 의존성을 주입하는 것 -->
<!-- @Resource -->
<!-- 자바에서 제공하는 어노테이션. 특정 프레임 워크에 종속적이지 않다.
이름 (name) 속성을 기준으로 먼저 찾고 없으면 타입 없으면 @Qualifier 어노테이션을 찾아
성공하면 찾은 속성에 의존성을 주입한다.
<context:annotation-config/> 구문을 꼭 xml 설정파일에 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드 -->
<!-- @Autowired -->
<!-- 스프링에서 지원하는 어노테이션.
주입하려고 하는 객체의 타입이 일치하는지 찾고 타입이 존재하지 않으면
속성명이 일치하는 bean을 컨테이너에서 찾는다. 이름이 없을경우 @Qualifier 어노테이션을 찾아
성공하면 찾은 속성에 의존성을 주입한다.
<context:annotation-config/> 구문을 꼭 xml 설정파일에 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드, 생성자, 일반 메소드 -->
<!-- @Inject -->
<!-- 자바에서 제공하는 어노테이션. 특정 프레임 워크에 종속적이지 않다.
@Aurowired와 동일하게 작동하지만 찾는 순서가 다르다.
타입, @Qualifier, 이름 순.
사용하기 위해서는 maven이나 gradle에 javax 라이브러리 의존성을 추가해야한다.
사용할 수 있는 위치 : 멤버변수, setter 메소드, 생성자, 일반 메소드  -->
<!-- @Qulifier-->
<!-- 타입이 동일한 bean객체가 여러개 있으면 주입 대상이 한 개여야 하는데 
실제로는 두개 이상의 빈이 존재해 주입할때 사용할 객체를 선택 할 수 없기 때문에
스프링 컨테이너를 초기화 하는 과정에서 Spring이 Exception을 일으킨다.
단, @Autowired가 적용된 필드나 설정 메서드의 property 이름과 같은 이름을 가진 빈 객체가 존재할 경우
이름이 같은 빈 객체를 주입받는다.
이럴때 @Qulifier에 한정자를 설정해줘서 해결한다. -->